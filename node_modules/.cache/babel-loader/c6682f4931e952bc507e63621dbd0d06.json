{"ast":null,"code":"import { __assign, __values, __spreadArray, __read, __rest } from './_virtual/_tslib.js';\nimport { STATE_DELIMITER } from './constants.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { isFunction, mapValues, isArray, flatten, keys, toArray, toStateValue, isString, getEventType, matchesState, path, evaluateGuard, mapContext, toSCXMLEvent, pathToStateValue, isBuiltInEvent, partition, updateHistoryValue, toStatePath, mapFilterValues, warn, toStatePaths, nestedPath, normalizeTarget, toGuard, toTransitionConfigArray, isMachine } from './utils.js';\nimport { SpecialTargets } from './types.js';\nimport { getAllStateNodes, getConfiguration, isInFinalState, getTagsFromConfiguration, has, getChildren, getValue, isLeafNode } from './stateUtils.js';\nimport { start as start$1, stop as stop$1, invoke, update, nullEvent, raise as raise$1, send as send$1 } from './actionTypes.js';\nimport { done, start, raise, stop, toActionObjects, resolveActions, doneInvoke, error, toActionObject, toActivityDefinition, after, send, cancel, initEvent } from './actions.js';\nimport { State, stateValuesEqual } from './State.js';\nimport { createInvocableActor } from './Actor.js';\nimport { toInvokeDefinition } from './invokeUtils.js';\nvar NULL_EVENT = '';\nvar STATE_IDENTIFIER = '#';\nvar WILDCARD = '*';\nvar EMPTY_OBJECT = {};\n\nvar isStateId = function (str) {\n  return str[0] === STATE_IDENTIFIER;\n};\n\nvar createDefaultOptions = function () {\n  return {\n    actions: {},\n    guards: {},\n    services: {},\n    activities: {},\n    delays: {}\n  };\n};\n\nvar validateArrayifiedTransitions = function (stateNode, event, transitions) {\n  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {\n    return !('cond' in transition) && !('in' in transition) && (isString(transition.target) || isMachine(transition.target));\n  });\n  var eventText = event === NULL_EVENT ? 'the transient event' : \"event '\".concat(event, \"'\");\n  warn(!hasNonLastUnguardedTarget, \"One or more transitions for \".concat(eventText, \" on state '\").concat(stateNode.id, \"' are unreachable. \") + \"Make sure that the default transition is the last one defined.\");\n};\n\nvar StateNode =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function StateNode(\n  /**\r\n   * The raw config used to create the machine.\r\n   */\n  config, options,\n  /**\r\n   * The initial extended state\r\n   */\n  _context // TODO: this is unsafe, but we're removing it in v5 anyway\n  ) {\n    var _this = this;\n\n    if (_context === void 0) {\n      _context = 'context' in config ? config.context : undefined;\n    }\n\n    var _a;\n\n    this.config = config;\n    this._context = _context;\n    /**\r\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\r\n     */\n\n    this.order = -1;\n    this.__xstatenode = true;\n    this.__cache = {\n      events: undefined,\n      relativeValue: new Map(),\n      initialStateValue: undefined,\n      initialState: undefined,\n      on: undefined,\n      transitions: undefined,\n      candidates: {},\n      delayedTransitions: undefined\n    };\n    this.idMap = {};\n    this.tags = [];\n    this.options = Object.assign(createDefaultOptions(), options);\n    this.parent = this.options._parent;\n    this.key = this.config.key || this.options._key || this.config.id || '(machine)';\n    this.machine = this.parent ? this.parent.machine : this;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);\n    this.id = this.config.id || __spreadArray([this.machine.key], __read(this.path), false).join(this.delimiter);\n    this.version = this.parent ? this.parent.version : this.config.version;\n    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.schema = this.parent ? this.machine.schema : (_a = this.config.schema) !== null && _a !== void 0 ? _a : {};\n    this.description = this.config.description;\n\n    if (!IS_PRODUCTION) {\n      warn(!('parallel' in this.config), \"The \\\"parallel\\\" property is deprecated and will be removed in version 4.1. \".concat(this.config.parallel ? \"Replace with `type: 'parallel'`\" : \"Use `type: '\".concat(this.type, \"'`\"), \" in the config for state node '\").concat(this.id, \"' instead.\"));\n    }\n\n    this.initial = this.config.initial;\n    this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {\n      var _a;\n\n      var stateNode = new StateNode(stateConfig, {\n        _parent: _this,\n        _key: key\n      });\n      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));\n      return stateNode;\n    }) : EMPTY_OBJECT; // Document order\n\n    var order = 0;\n\n    function dfs(stateNode) {\n      var e_1, _a;\n\n      stateNode.order = order++;\n\n      try {\n        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          dfs(child);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    dfs(this); // History config\n\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {\n      var event = _a.event;\n      return event === NULL_EVENT;\n    }) : NULL_EVENT in this.config.on);\n    this.strict = !!this.config.strict; // TODO: deprecate (entry)\n\n    this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function (action) {\n      return toActionObject(action);\n    }); // TODO: deprecate (exit)\n\n    this.onExit = toArray(this.config.exit || this.config.onExit).map(function (action) {\n      return toActionObject(action);\n    });\n    this.meta = this.config.meta;\n    this.doneData = this.type === 'final' ? this.config.data : undefined;\n    this.invoke = toArray(this.config.invoke).map(function (invokeConfig, i) {\n      var _a, _b;\n\n      if (isMachine(invokeConfig)) {\n        _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);\n        return toInvokeDefinition({\n          src: invokeConfig.id,\n          id: invokeConfig.id\n        });\n      } else if (isString(invokeConfig.src)) {\n        return toInvokeDefinition(__assign(__assign({}, invokeConfig), {\n          id: invokeConfig.id || invokeConfig.src,\n          src: invokeConfig.src\n        }));\n      } else if (isMachine(invokeConfig.src) || isFunction(invokeConfig.src)) {\n        var invokeSrc = \"\".concat(_this.id, \":invocation[\").concat(i, \"]\"); // TODO: util function\n\n        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);\n        return toInvokeDefinition(__assign(__assign({\n          id: invokeSrc\n        }, invokeConfig), {\n          src: invokeSrc\n        }));\n      } else {\n        var invokeSource = invokeConfig.src;\n        return toInvokeDefinition(__assign(__assign({\n          id: invokeSource.type\n        }, invokeConfig), {\n          src: invokeSource\n        }));\n      }\n    });\n    this.activities = toArray(this.config.activities).concat(this.invoke).map(function (activity) {\n      return toActivityDefinition(activity);\n    });\n    this.transition = this.transition.bind(this);\n    this.tags = toArray(this.config.tags); // TODO: this is the real fix for initialization once\n    // state node getters are deprecated\n    // if (!this.parent) {\n    //   this._init();\n    // }\n  }\n\n  StateNode.prototype._init = function () {\n    if (this.__cache.transitions) {\n      return;\n    }\n\n    getAllStateNodes(this).forEach(function (stateNode) {\n      return stateNode.on;\n    });\n  };\n  /**\r\n   * Clones this state machine with custom options and context.\r\n   *\r\n   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\r\n   * @param context Custom context (will override predefined context)\r\n   */\n\n\n  StateNode.prototype.withConfig = function (options, context) {\n    var _a = this.options,\n        actions = _a.actions,\n        activities = _a.activities,\n        guards = _a.guards,\n        services = _a.services,\n        delays = _a.delays;\n    return new StateNode(this.config, {\n      actions: __assign(__assign({}, actions), options.actions),\n      activities: __assign(__assign({}, activities), options.activities),\n      guards: __assign(__assign({}, guards), options.guards),\n      services: __assign(__assign({}, services), options.services),\n      delays: __assign(__assign({}, delays), options.delays)\n    }, context !== null && context !== void 0 ? context : this.context);\n  };\n  /**\r\n   * Clones this state machine with custom context.\r\n   *\r\n   * @param context Custom context (will override predefined context, not recursive)\r\n   */\n\n\n  StateNode.prototype.withContext = function (context) {\n    return new StateNode(this.config, this.options, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"context\", {\n    get: function () {\n      return isFunction(this._context) ? this._context() : this._context;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"definition\", {\n    /**\r\n     * The well-structured state node definition.\r\n     */\n    get: function () {\n      return {\n        id: this.id,\n        key: this.key,\n        version: this.version,\n        context: this.context,\n        type: this.type,\n        initial: this.initial,\n        history: this.history,\n        states: mapValues(this.states, function (state) {\n          return state.definition;\n        }),\n        on: this.on,\n        transitions: this.transitions,\n        entry: this.onEntry,\n        exit: this.onExit,\n        activities: this.activities || [],\n        meta: this.meta,\n        order: this.order || -1,\n        data: this.doneData,\n        invoke: this.invoke,\n        description: this.description,\n        tags: this.tags\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.toJSON = function () {\n    return this.definition;\n  };\n\n  Object.defineProperty(StateNode.prototype, \"on\", {\n    /**\r\n     * The mapping of events to transitions.\r\n     */\n    get: function () {\n      if (this.__cache.on) {\n        return this.__cache.on;\n      }\n\n      var transitions = this.transitions;\n      return this.__cache.on = transitions.reduce(function (map, transition) {\n        map[transition.eventType] = map[transition.eventType] || [];\n        map[transition.eventType].push(transition);\n        return map;\n      }, {});\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"after\", {\n    get: function () {\n      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"transitions\", {\n    /**\r\n     * All the transitions that can be taken from this state node.\r\n     */\n    get: function () {\n      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.getCandidates = function (eventName) {\n    if (this.__cache.candidates[eventName]) {\n      return this.__cache.candidates[eventName];\n    }\n\n    var transient = eventName === NULL_EVENT;\n    var candidates = this.transitions.filter(function (transition) {\n      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions\n\n      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;\n    });\n    this.__cache.candidates[eventName] = candidates;\n    return candidates;\n  };\n  /**\r\n   * All delayed transitions from the config.\r\n   */\n\n\n  StateNode.prototype.getDelayedTransitions = function () {\n    var _this = this;\n\n    var afterConfig = this.config.after;\n\n    if (!afterConfig) {\n      return [];\n    }\n\n    var mutateEntryExit = function (delay, i) {\n      var delayRef = isFunction(delay) ? \"\".concat(_this.id, \":delay[\").concat(i, \"]\") : delay;\n      var eventType = after(delayRef, _this.id);\n\n      _this.onEntry.push(send(eventType, {\n        delay: delay\n      }));\n\n      _this.onExit.push(cancel(eventType));\n\n      return eventType;\n    };\n\n    var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function (transition, i) {\n      var eventType = mutateEntryExit(transition.delay, i);\n      return __assign(__assign({}, transition), {\n        event: eventType\n      });\n    }) : flatten(keys(afterConfig).map(function (delay, i) {\n      var configTransition = afterConfig[delay];\n      var resolvedTransition = isString(configTransition) ? {\n        target: configTransition\n      } : configTransition;\n      var resolvedDelay = !isNaN(+delay) ? +delay : delay;\n      var eventType = mutateEntryExit(resolvedDelay, i);\n      return toArray(resolvedTransition).map(function (transition) {\n        return __assign(__assign({}, transition), {\n          event: eventType,\n          delay: resolvedDelay\n        });\n      });\n    }));\n    return delayedTransitions.map(function (delayedTransition) {\n      var delay = delayedTransition.delay;\n      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {\n        delay: delay\n      });\n    });\n  };\n  /**\r\n   * Returns the state nodes represented by the current state value.\r\n   *\r\n   * @param state The state value or State instance\r\n   */\n\n\n  StateNode.prototype.getStateNodes = function (state) {\n    var _a;\n\n    var _this = this;\n\n    if (!state) {\n      return [];\n    }\n\n    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);\n\n    if (isString(stateValue)) {\n      var initialStateValue = this.getStateNode(stateValue).initial;\n      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this, this.states[stateValue]];\n    }\n\n    var subStateKeys = keys(stateValue);\n    var subStateNodes = subStateKeys.map(function (subStateKey) {\n      return _this.getStateNode(subStateKey);\n    });\n    subStateNodes.push(this);\n    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {\n      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);\n\n      return allSubStateNodes.concat(subStateNode);\n    }, []));\n  };\n  /**\r\n   * Returns `true` if this state node explicitly handles the given event.\r\n   *\r\n   * @param event The event in question\r\n   */\n\n\n  StateNode.prototype.handles = function (event) {\n    var eventType = getEventType(event);\n    return this.events.includes(eventType);\n  };\n  /**\r\n   * Resolves the given `state` to a new `State` instance relative to this machine.\r\n   *\r\n   * This ensures that `.events` and `.nextEvents` represent the correct values.\r\n   *\r\n   * @param state The state to resolve\r\n   */\n\n\n  StateNode.prototype.resolveState = function (state) {\n    var configuration = Array.from(getConfiguration([], this.getStateNodes(state.value)));\n    return new State(__assign(__assign({}, state), {\n      value: this.resolve(state.value),\n      configuration: configuration,\n      done: isInFinalState(configuration, this),\n      tags: getTagsFromConfiguration(configuration)\n    }));\n  };\n\n  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {\n    var stateNode = this.getStateNode(stateValue);\n    var next = stateNode.next(state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {\n    var subStateKeys = keys(stateValue);\n    var stateNode = this.getStateNode(subStateKeys[0]);\n\n    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {\n    var e_2, _a;\n\n    var transitionMap = {};\n\n    try {\n      for (var _b = __values(keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var subStateKey = _c.value;\n        var subStateValue = stateValue[subStateKey];\n\n        if (!subStateValue) {\n          continue;\n        }\n\n        var subStateNode = this.getStateNode(subStateKey);\n\n        var next = subStateNode._transition(subStateValue, state, _event);\n\n        if (next) {\n          transitionMap[subStateKey] = next;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var stateTransitions = keys(transitionMap).map(function (key) {\n      return transitionMap[key];\n    });\n    var enabledTransitions = flatten(stateTransitions.map(function (st) {\n      return st.transitions;\n    }));\n    var willTransition = stateTransitions.some(function (st) {\n      return st.transitions.length > 0;\n    });\n\n    if (!willTransition) {\n      return this.next(state, _event);\n    }\n\n    var entryNodes = flatten(stateTransitions.map(function (t) {\n      return t.entrySet;\n    }));\n    var configuration = flatten(keys(transitionMap).map(function (key) {\n      return transitionMap[key].configuration;\n    }));\n    return {\n      transitions: enabledTransitions,\n      entrySet: entryNodes,\n      exitSet: flatten(stateTransitions.map(function (t) {\n        return t.exitSet;\n      })),\n      configuration: configuration,\n      source: state,\n      actions: flatten(keys(transitionMap).map(function (key) {\n        return transitionMap[key].actions;\n      }))\n    };\n  };\n\n  StateNode.prototype._transition = function (stateValue, state, _event) {\n    // leaf node\n    if (isString(stateValue)) {\n      return this.transitionLeafNode(stateValue, state, _event);\n    } // hierarchical node\n\n\n    if (keys(stateValue).length === 1) {\n      return this.transitionCompoundNode(stateValue, state, _event);\n    } // orthogonal node\n\n\n    return this.transitionParallelNode(stateValue, state, _event);\n  };\n\n  StateNode.prototype.next = function (state, _event) {\n    var e_3, _a;\n\n    var _this = this;\n\n    var eventName = _event.name;\n    var actions = [];\n    var nextStateNodes = [];\n    var selectedTransition;\n\n    try {\n      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var candidate = _c.value;\n        var cond = candidate.cond,\n            stateIn = candidate.in;\n        var resolvedContext = state.context;\n        var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? // Check if in state by ID\n        state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent\n        matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;\n        var guardPassed = false;\n\n        try {\n          guardPassed = !cond || evaluateGuard(this.machine, cond, resolvedContext, _event, state);\n        } catch (err) {\n          throw new Error(\"Unable to evaluate guard '\".concat(cond.name || cond.type, \"' in transition for event '\").concat(eventName, \"' in state node '\").concat(this.id, \"':\\n\").concat(err.message));\n        }\n\n        if (guardPassed && isInState) {\n          if (candidate.target !== undefined) {\n            nextStateNodes = candidate.target;\n          }\n\n          actions.push.apply(actions, __spreadArray([], __read(candidate.actions), false));\n          selectedTransition = candidate;\n          break;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    if (!selectedTransition) {\n      return undefined;\n    }\n\n    if (!nextStateNodes.length) {\n      return {\n        transitions: [selectedTransition],\n        entrySet: [],\n        exitSet: [],\n        configuration: state.value ? [this] : [],\n        source: state,\n        actions: actions\n      };\n    }\n\n    var allNextStateNodes = flatten(nextStateNodes.map(function (stateNode) {\n      return _this.getRelativeStateNodes(stateNode, state.historyValue);\n    }));\n    var isInternal = !!selectedTransition.internal;\n    var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function (n) {\n      return _this.nodesFromChild(n);\n    }));\n    return {\n      transitions: [selectedTransition],\n      entrySet: reentryNodes,\n      exitSet: isInternal ? [] : [this],\n      configuration: allNextStateNodes,\n      source: state,\n      actions: actions\n    };\n  };\n\n  StateNode.prototype.nodesFromChild = function (childStateNode) {\n    if (childStateNode.escapes(this)) {\n      return [];\n    }\n\n    var nodes = [];\n    var marker = childStateNode;\n\n    while (marker && marker !== this) {\n      nodes.push(marker);\n      marker = marker.parent;\n    }\n\n    nodes.push(this); // inclusive\n\n    return nodes;\n  };\n  /**\r\n   * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\r\n   * this state node, it does not escape.\r\n   */\n\n\n  StateNode.prototype.escapes = function (stateNode) {\n    if (this === stateNode) {\n      return false;\n    }\n\n    var parent = this.parent;\n\n    while (parent) {\n      if (parent === stateNode) {\n        return false;\n      }\n\n      parent = parent.parent;\n    }\n\n    return true;\n  };\n\n  StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {\n    var e_4, _a, e_5, _b;\n\n    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);\n    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;\n\n    try {\n      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {\n        var sn = resolvedConfig_1_1.value;\n\n        if (!has(prevConfig, sn)) {\n          transition.entrySet.push(sn);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {\n        var sn = prevConfig_1_1.value;\n\n        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {\n          transition.exitSet.push(sn);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    if (!transition.source) {\n      transition.exitSet = []; // Ensure that root StateNode (machine) is entered\n\n      transition.entrySet.push(this);\n    }\n\n    var doneEvents = flatten(transition.entrySet.map(function (sn) {\n      var events = [];\n\n      if (sn.type !== 'final') {\n        return events;\n      }\n\n      var parent = sn.parent;\n\n      if (!parent.parent) {\n        return events;\n      }\n\n      events.push(done(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.\n      done(parent.id, sn.doneData ? mapContext(sn.doneData, currentContext, _event) : undefined));\n      var grandparent = parent.parent;\n\n      if (grandparent.type === 'parallel') {\n        if (getChildren(grandparent).every(function (parentNode) {\n          return isInFinalState(transition.configuration, parentNode);\n        })) {\n          events.push(done(grandparent.id));\n        }\n      }\n\n      return events;\n    }));\n    transition.exitSet.sort(function (a, b) {\n      return b.order - a.order;\n    });\n    transition.entrySet.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    var entryStates = new Set(transition.entrySet);\n    var exitStates = new Set(transition.exitSet);\n\n    var _c = __read([flatten(Array.from(entryStates).map(function (stateNode) {\n      return __spreadArray(__spreadArray([], __read(stateNode.activities.map(function (activity) {\n        return start(activity);\n      })), false), __read(stateNode.onEntry), false);\n    })).concat(doneEvents.map(raise)), flatten(Array.from(exitStates).map(function (stateNode) {\n      return __spreadArray(__spreadArray([], __read(stateNode.onExit), false), __read(stateNode.activities.map(function (activity) {\n        return stop(activity);\n      })), false);\n    }))], 2),\n        entryActions = _c[0],\n        exitActions = _c[1];\n\n    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);\n    return actions;\n  };\n  /**\r\n   * Determines the next state given the current `state` and sent `event`.\r\n   *\r\n   * @param state The current State instance or state value\r\n   * @param event The event that was sent at the current state\r\n   * @param context The current context (extended state) of the current state\r\n   */\n\n\n  StateNode.prototype.transition = function (state, event, context) {\n    if (state === void 0) {\n      state = this.initialState;\n    }\n\n    var _event = toSCXMLEvent(event);\n\n    var currentState;\n\n    if (state instanceof State) {\n      currentState = context === undefined ? state : this.resolveState(State.from(state, context));\n    } else {\n      var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);\n      var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;\n      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));\n    }\n\n    if (!IS_PRODUCTION && _event.name === WILDCARD) {\n      throw new Error(\"An event cannot have the wildcard type ('\".concat(WILDCARD, \"')\"));\n    }\n\n    if (this.strict) {\n      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {\n        throw new Error(\"Machine '\".concat(this.id, \"' does not accept event '\").concat(_event.name, \"'\"));\n      }\n    }\n\n    var stateTransition = this._transition(currentState.value, currentState, _event) || {\n      transitions: [],\n      configuration: [],\n      entrySet: [],\n      exitSet: [],\n      source: currentState,\n      actions: []\n    };\n    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));\n    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;\n    stateTransition.configuration = __spreadArray([], __read(resolvedConfig), false);\n    return this.resolveTransition(stateTransition, currentState, _event);\n  };\n\n  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {\n    var _a;\n\n    var currentActions = state.actions;\n    state = this.transition(state, _event); // Save original event to state\n    // TODO: this should be the raised event! Delete in V5 (breaking)\n\n    state._event = originalEvent;\n    state.event = originalEvent.data;\n\n    (_a = state.actions).unshift.apply(_a, __spreadArray([], __read(currentActions), false));\n\n    return state;\n  };\n\n  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {\n    var e_6, _a;\n\n    var _this = this;\n\n    if (_event === void 0) {\n      _event = initEvent;\n    }\n\n    if (context === void 0) {\n      context = this.machine.context;\n    }\n\n    var configuration = stateTransition.configuration; // Transition will \"apply\" if:\n    // - this is the initial state (there is no current state)\n    // - OR there are transitions\n\n    var willTransition = !currentState || stateTransition.transitions.length > 0;\n    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;\n    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;\n    var currentContext = currentState ? currentState.context : context;\n    var actions = this.getActions(stateTransition, currentContext, _event, currentState);\n    var activities = currentState ? __assign({}, currentState.activities) : {};\n\n    try {\n      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {\n        var action = actions_1_1.value;\n\n        if (action.type === start$1) {\n          activities[action.activity.id || action.activity.type] = action;\n        } else if (action.type === stop$1) {\n          activities[action.activity.id || action.activity.type] = false;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    var _b = __read(resolveActions(this, currentState, currentContext, _event, actions, this.machine.config.preserveActionOrder), 2),\n        resolvedActions = _b[0],\n        updatedContext = _b[1];\n\n    var _c = __read(partition(resolvedActions, function (action) {\n      return action.type === raise$1 || action.type === send$1 && action.to === SpecialTargets.Internal;\n    }), 2),\n        raisedEvents = _c[0],\n        nonRaisedActions = _c[1];\n\n    var invokeActions = resolvedActions.filter(function (action) {\n      var _a;\n\n      return action.type === start$1 && ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) === invoke;\n    });\n    var children = invokeActions.reduce(function (acc, action) {\n      acc[action.activity.id] = createInvocableActor(action.activity, _this.machine, updatedContext, _event);\n      return acc;\n    }, currentState ? __assign({}, currentState.children) : {});\n    var resolvedConfiguration = resolvedStateValue ? stateTransition.configuration : currentState ? currentState.configuration : [];\n    var isDone = isInFinalState(resolvedConfiguration, this);\n    var nextState = new State({\n      value: resolvedStateValue || currentState.value,\n      context: updatedContext,\n      _event: _event,\n      // Persist _sessionid between states\n      _sessionid: currentState ? currentState._sessionid : null,\n      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,\n      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,\n      actions: resolvedStateValue ? nonRaisedActions : [],\n      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},\n      events: [],\n      configuration: resolvedConfiguration,\n      transitions: stateTransition.transitions,\n      children: children,\n      done: isDone,\n      tags: currentState === null || currentState === void 0 ? void 0 : currentState.tags,\n      machine: this\n    });\n    var didUpdateContext = currentContext !== updatedContext;\n    nextState.changed = _event.name === update || didUpdateContext; // Dispose of penultimate histories to prevent memory leaks\n\n    var history = nextState.history;\n\n    if (history) {\n      delete history.history;\n    } // There are transient transitions if the machine is not in a final state\n    // and if some of the state nodes have transient (\"always\") transitions.\n\n\n    var isTransient = !isDone && (this._transient || configuration.some(function (stateNode) {\n      return stateNode._transient;\n    })); // If there are no enabled transitions, check if there are transient transitions.\n    // If there are transient transitions, continue checking for more transitions\n    // because an transient transition should be triggered even if there are no\n    // enabled transitions.\n    //\n    // If we're already working on an transient transition (by checking\n    // if the event is a NULL_EVENT), then stop to prevent an infinite loop.\n    //\n    // Otherwise, if there are no enabled nor transient transitions, we are done.\n\n    if (!willTransition && (!isTransient || _event.name === NULL_EVENT)) {\n      return nextState;\n    }\n\n    var maybeNextState = nextState;\n\n    if (!isDone) {\n      if (isTransient) {\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, {\n          type: nullEvent\n        }, _event);\n      }\n\n      while (raisedEvents.length) {\n        var raisedEvent = raisedEvents.shift();\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);\n      }\n    } // Detect if state changed\n\n\n    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);\n    maybeNextState.changed = changed; // Preserve original history after raised events\n\n    maybeNextState.history = history;\n    maybeNextState.tags = getTagsFromConfiguration(maybeNextState.configuration);\n    return maybeNextState;\n  };\n  /**\r\n   * Returns the child state node from its relative `stateKey`, or throws.\r\n   */\n\n\n  StateNode.prototype.getStateNode = function (stateKey) {\n    if (isStateId(stateKey)) {\n      return this.machine.getStateNodeById(stateKey);\n    }\n\n    if (!this.states) {\n      throw new Error(\"Unable to retrieve child state '\".concat(stateKey, \"' from '\").concat(this.id, \"'; no child states exist.\"));\n    }\n\n    var result = this.states[stateKey];\n\n    if (!result) {\n      throw new Error(\"Child state '\".concat(stateKey, \"' does not exist on '\").concat(this.id, \"'\"));\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the state node with the given `stateId`, or throws.\r\n   *\r\n   * @param stateId The state ID. The prefix \"#\" is removed.\r\n   */\n\n\n  StateNode.prototype.getStateNodeById = function (stateId) {\n    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;\n\n    if (resolvedStateId === this.id) {\n      return this;\n    }\n\n    var stateNode = this.machine.idMap[resolvedStateId];\n\n    if (!stateNode) {\n      throw new Error(\"Child state node '#\".concat(resolvedStateId, \"' does not exist on machine '\").concat(this.id, \"'\"));\n    }\n\n    return stateNode;\n  };\n  /**\r\n   * Returns the relative state node from the given `statePath`, or throws.\r\n   *\r\n   * @param statePath The string or string array relative path to the state node.\r\n   */\n\n\n  StateNode.prototype.getStateNodeByPath = function (statePath) {\n    if (typeof statePath === 'string' && isStateId(statePath)) {\n      try {\n        return this.getStateNodeById(statePath.slice(1));\n      } catch (e) {// try individual paths\n        // throw e;\n      }\n    }\n\n    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();\n    var currentStateNode = this;\n\n    while (arrayStatePath.length) {\n      var key = arrayStatePath.shift();\n\n      if (!key.length) {\n        break;\n      }\n\n      currentStateNode = currentStateNode.getStateNode(key);\n    }\n\n    return currentStateNode;\n  };\n  /**\r\n   * Resolves a partial state value with its full representation in this machine.\r\n   *\r\n   * @param stateValue The partial state value to resolve.\r\n   */\n\n\n  StateNode.prototype.resolve = function (stateValue) {\n    var _a;\n\n    var _this = this;\n\n    if (!stateValue) {\n      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties\n    }\n\n    switch (this.type) {\n      case 'parallel':\n        return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;\n        });\n\n      case 'compound':\n        if (isString(stateValue)) {\n          var subStateNode = this.getStateNode(stateValue);\n\n          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {\n            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;\n          }\n\n          return stateValue;\n        }\n\n        if (!keys(stateValue).length) {\n          return this.initialStateValue || {};\n        }\n\n        return mapValues(stateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;\n        });\n\n      default:\n        return stateValue || EMPTY_OBJECT;\n    }\n  };\n\n  StateNode.prototype.getResolvedPath = function (stateIdentifier) {\n    if (isStateId(stateIdentifier)) {\n      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];\n\n      if (!stateNode) {\n        throw new Error(\"Unable to find state node '\".concat(stateIdentifier, \"'\"));\n      }\n\n      return stateNode.path;\n    }\n\n    return toStatePath(stateIdentifier, this.delimiter);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateValue\", {\n    get: function () {\n      var _a;\n\n      if (this.__cache.initialStateValue) {\n        return this.__cache.initialStateValue;\n      }\n\n      var initialStateValue;\n\n      if (this.type === 'parallel') {\n        initialStateValue = mapFilterValues(this.states, function (state) {\n          return state.initialStateValue || EMPTY_OBJECT;\n        }, function (stateNode) {\n          return !(stateNode.type === 'history');\n        });\n      } else if (this.initial !== undefined) {\n        if (!this.states[this.initial]) {\n          throw new Error(\"Initial state '\".concat(this.initial, \"' not found on '\").concat(this.key, \"'\"));\n        }\n\n        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);\n      } else {\n        // The finite state value of a machine without child states is just an empty object\n        initialStateValue = {};\n      }\n\n      this.__cache.initialStateValue = initialStateValue;\n      return this.__cache.initialStateValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.getInitialState = function (stateValue, context) {\n    var configuration = this.getStateNodes(stateValue);\n    return this.resolveTransition({\n      configuration: configuration,\n      entrySet: configuration,\n      exitSet: [],\n      transitions: [],\n      source: undefined,\n      actions: []\n    }, undefined, undefined, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialState\", {\n    /**\r\n     * The initial State instance, which includes all actions to be executed from\r\n     * entering the initial state.\r\n     */\n    get: function () {\n      this._init(); // TODO: this should be in the constructor (see note in constructor)\n\n\n      var initialStateValue = this.initialStateValue;\n\n      if (!initialStateValue) {\n        throw new Error(\"Cannot retrieve initial state from simple state '\".concat(this.id, \"'.\"));\n      }\n\n      return this.getInitialState(initialStateValue);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"target\", {\n    /**\r\n     * The target state value of the history state node, if it exists. This represents the\r\n     * default state value to transition to if no history value exists yet.\r\n     */\n    get: function () {\n      var target;\n\n      if (this.type === 'history') {\n        var historyConfig = this.config;\n\n        if (isString(historyConfig.target)) {\n          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;\n        } else {\n          target = historyConfig.target;\n        }\n      }\n\n      return target;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the leaf nodes from a state path relative to this state node.\r\n   *\r\n   * @param relativeStateId The relative state path to retrieve the state nodes\r\n   * @param history The previous state to retrieve history\r\n   * @param resolve Whether state nodes should resolve to initial child state nodes\r\n   */\n\n  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {\n    if (resolve === void 0) {\n      resolve = true;\n    }\n\n    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateNodes\", {\n    get: function () {\n      var _this = this;\n\n      if (isLeafNode(this)) {\n        return [this];\n      } // Case when state node is compound but no initial state is defined\n\n\n      if (this.type === 'compound' && !this.initial) {\n        if (!IS_PRODUCTION) {\n          warn(false, \"Compound state node '\".concat(this.id, \"' has no initial state.\"));\n        }\n\n        return [this];\n      }\n\n      var initialStateNodePaths = toStatePaths(this.initialStateValue);\n      return flatten(initialStateNodePaths.map(function (initialPath) {\n        return _this.getFromRelativePath(initialPath);\n      }));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Retrieves state nodes from a relative path to this state node.\r\n   *\r\n   * @param relativePath The relative path from this state node\r\n   * @param historyValue\r\n   */\n\n  StateNode.prototype.getFromRelativePath = function (relativePath) {\n    if (!relativePath.length) {\n      return [this];\n    }\n\n    var _a = __read(relativePath),\n        stateKey = _a[0],\n        childStatePath = _a.slice(1);\n\n    if (!this.states) {\n      throw new Error(\"Cannot retrieve subPath '\".concat(stateKey, \"' from node with no states\"));\n    }\n\n    var childStateNode = this.getStateNode(stateKey);\n\n    if (childStateNode.type === 'history') {\n      return childStateNode.resolveHistory();\n    }\n\n    if (!this.states[stateKey]) {\n      throw new Error(\"Child state '\".concat(stateKey, \"' does not exist on '\").concat(this.id, \"'\"));\n    }\n\n    return this.states[stateKey].getFromRelativePath(childStatePath);\n  };\n\n  StateNode.prototype.historyValue = function (relativeStateValue) {\n    if (!keys(this.states).length) {\n      return undefined;\n    }\n\n    return {\n      current: relativeStateValue || this.initialStateValue,\n      states: mapFilterValues(this.states, function (stateNode, key) {\n        if (!relativeStateValue) {\n          return stateNode.historyValue();\n        }\n\n        var subStateValue = isString(relativeStateValue) ? undefined : relativeStateValue[key];\n        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);\n      }, function (stateNode) {\n        return !stateNode.history;\n      })\n    };\n  };\n  /**\r\n   * Resolves to the historical value(s) of the parent state node,\r\n   * represented by state nodes.\r\n   *\r\n   * @param historyValue\r\n   */\n\n\n  StateNode.prototype.resolveHistory = function (historyValue) {\n    var _this = this;\n\n    if (this.type !== 'history') {\n      return [this];\n    }\n\n    var parent = this.parent;\n\n    if (!historyValue) {\n      var historyTarget = this.target;\n      return historyTarget ? flatten(toStatePaths(historyTarget).map(function (relativeChildPath) {\n        return parent.getFromRelativePath(relativeChildPath);\n      })) : parent.initialStateNodes;\n    }\n\n    var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;\n\n    if (isString(subHistoryValue)) {\n      return [parent.getStateNode(subHistoryValue)];\n    }\n\n    return flatten(toStatePaths(subHistoryValue).map(function (subStatePath) {\n      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];\n    }));\n  };\n\n  Object.defineProperty(StateNode.prototype, \"stateIds\", {\n    /**\r\n     * All the state node IDs of this state node and its descendant state nodes.\r\n     */\n    get: function () {\n      var _this = this;\n\n      var childStateIds = flatten(keys(this.states).map(function (stateKey) {\n        return _this.states[stateKey].stateIds;\n      }));\n      return [this.id].concat(childStateIds);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"events\", {\n    /**\r\n     * All the event types accepted by this state node and its descendants.\r\n     */\n    get: function () {\n      var e_7, _a, e_8, _b;\n\n      if (this.__cache.events) {\n        return this.__cache.events;\n      }\n\n      var states = this.states;\n      var events = new Set(this.ownEvents);\n\n      if (states) {\n        try {\n          for (var _c = __values(keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var stateId = _d.value;\n            var state = states[stateId];\n\n            if (state.states) {\n              try {\n                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var event_1 = _f.value;\n                  events.add(\"\".concat(event_1));\n                }\n              } catch (e_8_1) {\n                e_8 = {\n                  error: e_8_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_8) throw e_8.error;\n                }\n              }\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n\n      return this.__cache.events = Array.from(events);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"ownEvents\", {\n    /**\r\n     * All the events that have transitions directly from this state node.\r\n     *\r\n     * Excludes any inert events.\r\n     */\n    get: function () {\n      var events = new Set(this.transitions.filter(function (transition) {\n        return !(!transition.target && !transition.actions.length && transition.internal);\n      }).map(function (transition) {\n        return transition.eventType;\n      }));\n      return Array.from(events);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.resolveTarget = function (_target) {\n    var _this = this;\n\n    if (_target === undefined) {\n      // an undefined target signals that the state node should not transition from that state when receiving that event\n      return undefined;\n    }\n\n    return _target.map(function (target) {\n      if (!isString(target)) {\n        return target;\n      }\n\n      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,\n      // do not include machine key on target\n\n      if (isInternalTarget && !_this.parent) {\n        return _this.getStateNodeByPath(target.slice(1));\n      }\n\n      var resolvedTarget = isInternalTarget ? _this.key + target : target;\n\n      if (_this.parent) {\n        try {\n          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);\n\n          return targetStateNode;\n        } catch (err) {\n          throw new Error(\"Invalid transition definition for state node '\".concat(_this.id, \"':\\n\").concat(err.message));\n        }\n      } else {\n        return _this.getStateNodeByPath(resolvedTarget);\n      }\n    });\n  };\n\n  StateNode.prototype.formatTransition = function (transitionConfig) {\n    var _this = this;\n\n    var normalizedTarget = normalizeTarget(transitionConfig.target);\n    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {\n      return isString(_target) && _target[0] === _this.delimiter;\n    }) : true;\n    var guards = this.machine.options.guards;\n    var target = this.resolveTarget(normalizedTarget);\n\n    var transition = __assign(__assign({}, transitionConfig), {\n      actions: toActionObjects(toArray(transitionConfig.actions)),\n      cond: toGuard(transitionConfig.cond, guards),\n      target: target,\n      source: this,\n      internal: internal,\n      eventType: transitionConfig.event,\n      toJSON: function () {\n        return __assign(__assign({}, transition), {\n          target: transition.target ? transition.target.map(function (t) {\n            return \"#\".concat(t.id);\n          }) : undefined,\n          source: \"#\".concat(_this.id)\n        });\n      }\n    });\n\n    return transition;\n  };\n\n  StateNode.prototype.formatTransitions = function () {\n    var e_9, _a;\n\n    var _this = this;\n\n    var onConfig;\n\n    if (!this.config.on) {\n      onConfig = [];\n    } else if (Array.isArray(this.config.on)) {\n      onConfig = this.config.on;\n    } else {\n      var _b = this.config.on,\n          _c = WILDCARD,\n          _d = _b[_c],\n          wildcardConfigs = _d === void 0 ? [] : _d,\n          strictTransitionConfigs_1 = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\"]);\n\n      onConfig = flatten(keys(strictTransitionConfigs_1).map(function (key) {\n        if (!IS_PRODUCTION && key === NULL_EVENT) {\n          warn(false, \"Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. \" + \"Please check the `on` configuration for \\\"#\".concat(_this.id, \"\\\".\"));\n        }\n\n        var transitionConfigArray = toTransitionConfigArray(key, strictTransitionConfigs_1[key]);\n\n        if (!IS_PRODUCTION) {\n          validateArrayifiedTransitions(_this, key, transitionConfigArray);\n        }\n\n        return transitionConfigArray;\n      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));\n    }\n\n    var eventlessConfig = this.config.always ? toTransitionConfigArray('', this.config.always) : [];\n    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];\n\n    if (!IS_PRODUCTION) {\n      warn(!(this.config.onDone && !this.parent), \"Root nodes cannot have an \\\".onDone\\\" transition. Please check the config of \\\"\".concat(this.id, \"\\\".\"));\n    }\n\n    var invokeConfig = flatten(this.invoke.map(function (invokeDef) {\n      var settleTransitions = [];\n\n      if (invokeDef.onDone) {\n        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)), false));\n      }\n\n      if (invokeDef.onError) {\n        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)), false));\n      }\n\n      return settleTransitions;\n    }));\n    var delayedTransitions = this.after;\n    var formattedTransitions = flatten(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(doneConfig), false), __read(invokeConfig), false), __read(onConfig), false), __read(eventlessConfig), false).map(function (transitionConfig) {\n      return toArray(transitionConfig).map(function (transition) {\n        return _this.formatTransition(transition);\n      });\n    }));\n\n    try {\n      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {\n        var delayedTransition = delayedTransitions_1_1.value;\n        formattedTransitions.push(delayedTransition);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    return formattedTransitions;\n  };\n\n  return StateNode;\n}();\n\nexport { StateNode };","map":{"version":3,"sources":["/home/guillermo/project/certificate-project2/node_modules/xstate/es/StateNode.js"],"names":["__assign","__values","__spreadArray","__read","__rest","STATE_DELIMITER","IS_PRODUCTION","isFunction","mapValues","isArray","flatten","keys","toArray","toStateValue","isString","getEventType","matchesState","path","evaluateGuard","mapContext","toSCXMLEvent","pathToStateValue","isBuiltInEvent","partition","updateHistoryValue","toStatePath","mapFilterValues","warn","toStatePaths","nestedPath","normalizeTarget","toGuard","toTransitionConfigArray","isMachine","SpecialTargets","getAllStateNodes","getConfiguration","isInFinalState","getTagsFromConfiguration","has","getChildren","getValue","isLeafNode","start","start$1","stop","stop$1","invoke","update","nullEvent","raise","raise$1","send","send$1","done","toActionObjects","resolveActions","doneInvoke","error","toActionObject","toActivityDefinition","after","cancel","initEvent","State","stateValuesEqual","createInvocableActor","toInvokeDefinition","NULL_EVENT","STATE_IDENTIFIER","WILDCARD","EMPTY_OBJECT","isStateId","str","createDefaultOptions","actions","guards","services","activities","delays","validateArrayifiedTransitions","stateNode","event","transitions","hasNonLastUnguardedTarget","slice","some","transition","target","eventText","concat","id","StateNode","config","options","_context","_this","context","undefined","_a","order","__xstatenode","__cache","events","relativeValue","Map","initialStateValue","initialState","on","candidates","delayedTransitions","idMap","tags","Object","assign","parent","_parent","key","_key","machine","delimiter","join","version","type","parallel","states","length","history","schema","description","initial","stateConfig","dfs","e_1","_b","_c","next","child","value","e_1_1","return","call","_transient","always","Array","strict","onEntry","entry","map","action","onExit","exit","meta","doneData","data","invokeConfig","i","src","invokeSrc","invokeSource","activity","bind","prototype","_init","forEach","withConfig","withContext","defineProperty","get","enumerable","configurable","state","definition","toJSON","reduce","eventType","push","getDelayedTransitions","formatTransitions","getCandidates","eventName","transient","filter","sameEventType","afterConfig","mutateEntryExit","delay","delayRef","configTransition","resolvedTransition","resolvedDelay","isNaN","delayedTransition","formatTransition","getStateNodes","stateValue","getStateNode","subStateKeys","subStateNodes","subStateKey","allSubStateNodes","subStateNode","handles","includes","resolveState","configuration","from","resolve","transitionLeafNode","_event","transitionCompoundNode","_transition","transitionParallelNode","e_2","transitionMap","subStateValue","e_2_1","stateTransitions","enabledTransitions","st","willTransition","entryNodes","t","entrySet","exitSet","source","e_3","name","nextStateNodes","selectedTransition","candidate","cond","stateIn","in","resolvedContext","isInState","matches","getStateNodeById","guardPassed","err","Error","message","apply","e_3_1","allNextStateNodes","getRelativeStateNodes","historyValue","isInternal","internal","reentryNodes","n","nodesFromChild","childStateNode","escapes","nodes","marker","getActions","currentContext","prevState","e_4","e_5","prevConfig","resolvedConfig","resolvedConfig_1","resolvedConfig_1_1","sn","e_4_1","prevConfig_1","prevConfig_1_1","e_5_1","doneEvents","grandparent","every","parentNode","sort","a","b","entryStates","Set","exitStates","entryActions","exitActions","currentState","resolvedStateValue","getResolvedPath","stateTransition","resolveTransition","resolveRaisedTransition","originalEvent","currentActions","unshift","e_6","actions_1","actions_1_1","e_6_1","preserveActionOrder","resolvedActions","updatedContext","to","Internal","raisedEvents","nonRaisedActions","invokeActions","children","acc","resolvedConfiguration","isDone","nextState","_sessionid","didUpdateContext","changed","isTransient","maybeNextState","raisedEvent","shift","stateKey","result","stateId","resolvedStateId","getStateNodeByPath","statePath","e","arrayStatePath","currentStateNode","stateIdentifier","getInitialState","historyConfig","relativeStateId","resolveHistory","initialStateNodes","initialStateNodePaths","initialPath","getFromRelativePath","relativePath","childStatePath","relativeStateValue","current","historyTarget","relativeChildPath","subHistoryValue","subStatePath","childStateIds","stateIds","e_7","e_8","ownEvents","_d","_e","_f","event_1","add","e_8_1","e_7_1","resolveTarget","_target","isInternalTarget","resolvedTarget","targetStateNode","transitionConfig","normalizedTarget","e_9","onConfig","wildcardConfigs","strictTransitionConfigs_1","transitionConfigArray","eventlessConfig","doneConfig","onDone","String","invokeDef","settleTransitions","onError","formattedTransitions","delayedTransitions_1","delayedTransitions_1_1","e_9_1"],"mappings":"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","sourcesContent":["import { __assign, __values, __spreadArray, __read, __rest } from './_virtual/_tslib.js';\nimport { STATE_DELIMITER } from './constants.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { isFunction, mapValues, isArray, flatten, keys, toArray, toStateValue, isString, getEventType, matchesState, path, evaluateGuard, mapContext, toSCXMLEvent, pathToStateValue, isBuiltInEvent, partition, updateHistoryValue, toStatePath, mapFilterValues, warn, toStatePaths, nestedPath, normalizeTarget, toGuard, toTransitionConfigArray, isMachine } from './utils.js';\nimport { SpecialTargets } from './types.js';\nimport { getAllStateNodes, getConfiguration, isInFinalState, getTagsFromConfiguration, has, getChildren, getValue, isLeafNode } from './stateUtils.js';\nimport { start as start$1, stop as stop$1, invoke, update, nullEvent, raise as raise$1, send as send$1 } from './actionTypes.js';\nimport { done, start, raise, stop, toActionObjects, resolveActions, doneInvoke, error, toActionObject, toActivityDefinition, after, send, cancel, initEvent } from './actions.js';\nimport { State, stateValuesEqual } from './State.js';\nimport { createInvocableActor } from './Actor.js';\nimport { toInvokeDefinition } from './invokeUtils.js';\n\nvar NULL_EVENT = '';\nvar STATE_IDENTIFIER = '#';\nvar WILDCARD = '*';\nvar EMPTY_OBJECT = {};\n\nvar isStateId = function (str) {\n  return str[0] === STATE_IDENTIFIER;\n};\n\nvar createDefaultOptions = function () {\n  return {\n    actions: {},\n    guards: {},\n    services: {},\n    activities: {},\n    delays: {}\n  };\n};\n\nvar validateArrayifiedTransitions = function (stateNode, event, transitions) {\n  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {\n    return !('cond' in transition) && !('in' in transition) && (isString(transition.target) || isMachine(transition.target));\n  });\n  var eventText = event === NULL_EVENT ? 'the transient event' : \"event '\".concat(event, \"'\");\n  warn(!hasNonLastUnguardedTarget, \"One or more transitions for \".concat(eventText, \" on state '\").concat(stateNode.id, \"' are unreachable. \") + \"Make sure that the default transition is the last one defined.\");\n};\n\nvar StateNode =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function StateNode(\n  /**\r\n   * The raw config used to create the machine.\r\n   */\n  config, options,\n  /**\r\n   * The initial extended state\r\n   */\n  _context // TODO: this is unsafe, but we're removing it in v5 anyway\n  ) {\n    var _this = this;\n\n    if (_context === void 0) {\n      _context = 'context' in config ? config.context : undefined;\n    }\n\n    var _a;\n\n    this.config = config;\n    this._context = _context;\n    /**\r\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\r\n     */\n\n    this.order = -1;\n    this.__xstatenode = true;\n    this.__cache = {\n      events: undefined,\n      relativeValue: new Map(),\n      initialStateValue: undefined,\n      initialState: undefined,\n      on: undefined,\n      transitions: undefined,\n      candidates: {},\n      delayedTransitions: undefined\n    };\n    this.idMap = {};\n    this.tags = [];\n    this.options = Object.assign(createDefaultOptions(), options);\n    this.parent = this.options._parent;\n    this.key = this.config.key || this.options._key || this.config.id || '(machine)';\n    this.machine = this.parent ? this.parent.machine : this;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);\n    this.id = this.config.id || __spreadArray([this.machine.key], __read(this.path), false).join(this.delimiter);\n    this.version = this.parent ? this.parent.version : this.config.version;\n    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.schema = this.parent ? this.machine.schema : (_a = this.config.schema) !== null && _a !== void 0 ? _a : {};\n    this.description = this.config.description;\n\n    if (!IS_PRODUCTION) {\n      warn(!('parallel' in this.config), \"The \\\"parallel\\\" property is deprecated and will be removed in version 4.1. \".concat(this.config.parallel ? \"Replace with `type: 'parallel'`\" : \"Use `type: '\".concat(this.type, \"'`\"), \" in the config for state node '\").concat(this.id, \"' instead.\"));\n    }\n\n    this.initial = this.config.initial;\n    this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {\n      var _a;\n\n      var stateNode = new StateNode(stateConfig, {\n        _parent: _this,\n        _key: key\n      });\n      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));\n      return stateNode;\n    }) : EMPTY_OBJECT; // Document order\n\n    var order = 0;\n\n    function dfs(stateNode) {\n      var e_1, _a;\n\n      stateNode.order = order++;\n\n      try {\n        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          dfs(child);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    dfs(this); // History config\n\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {\n      var event = _a.event;\n      return event === NULL_EVENT;\n    }) : NULL_EVENT in this.config.on);\n    this.strict = !!this.config.strict; // TODO: deprecate (entry)\n\n    this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function (action) {\n      return toActionObject(action);\n    }); // TODO: deprecate (exit)\n\n    this.onExit = toArray(this.config.exit || this.config.onExit).map(function (action) {\n      return toActionObject(action);\n    });\n    this.meta = this.config.meta;\n    this.doneData = this.type === 'final' ? this.config.data : undefined;\n    this.invoke = toArray(this.config.invoke).map(function (invokeConfig, i) {\n      var _a, _b;\n\n      if (isMachine(invokeConfig)) {\n        _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);\n        return toInvokeDefinition({\n          src: invokeConfig.id,\n          id: invokeConfig.id\n        });\n      } else if (isString(invokeConfig.src)) {\n        return toInvokeDefinition(__assign(__assign({}, invokeConfig), {\n          id: invokeConfig.id || invokeConfig.src,\n          src: invokeConfig.src\n        }));\n      } else if (isMachine(invokeConfig.src) || isFunction(invokeConfig.src)) {\n        var invokeSrc = \"\".concat(_this.id, \":invocation[\").concat(i, \"]\"); // TODO: util function\n\n        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);\n        return toInvokeDefinition(__assign(__assign({\n          id: invokeSrc\n        }, invokeConfig), {\n          src: invokeSrc\n        }));\n      } else {\n        var invokeSource = invokeConfig.src;\n        return toInvokeDefinition(__assign(__assign({\n          id: invokeSource.type\n        }, invokeConfig), {\n          src: invokeSource\n        }));\n      }\n    });\n    this.activities = toArray(this.config.activities).concat(this.invoke).map(function (activity) {\n      return toActivityDefinition(activity);\n    });\n    this.transition = this.transition.bind(this);\n    this.tags = toArray(this.config.tags); // TODO: this is the real fix for initialization once\n    // state node getters are deprecated\n    // if (!this.parent) {\n    //   this._init();\n    // }\n  }\n\n  StateNode.prototype._init = function () {\n    if (this.__cache.transitions) {\n      return;\n    }\n\n    getAllStateNodes(this).forEach(function (stateNode) {\n      return stateNode.on;\n    });\n  };\n  /**\r\n   * Clones this state machine with custom options and context.\r\n   *\r\n   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\r\n   * @param context Custom context (will override predefined context)\r\n   */\n\n\n  StateNode.prototype.withConfig = function (options, context) {\n    var _a = this.options,\n        actions = _a.actions,\n        activities = _a.activities,\n        guards = _a.guards,\n        services = _a.services,\n        delays = _a.delays;\n    return new StateNode(this.config, {\n      actions: __assign(__assign({}, actions), options.actions),\n      activities: __assign(__assign({}, activities), options.activities),\n      guards: __assign(__assign({}, guards), options.guards),\n      services: __assign(__assign({}, services), options.services),\n      delays: __assign(__assign({}, delays), options.delays)\n    }, context !== null && context !== void 0 ? context : this.context);\n  };\n  /**\r\n   * Clones this state machine with custom context.\r\n   *\r\n   * @param context Custom context (will override predefined context, not recursive)\r\n   */\n\n\n  StateNode.prototype.withContext = function (context) {\n    return new StateNode(this.config, this.options, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"context\", {\n    get: function () {\n      return isFunction(this._context) ? this._context() : this._context;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"definition\", {\n    /**\r\n     * The well-structured state node definition.\r\n     */\n    get: function () {\n      return {\n        id: this.id,\n        key: this.key,\n        version: this.version,\n        context: this.context,\n        type: this.type,\n        initial: this.initial,\n        history: this.history,\n        states: mapValues(this.states, function (state) {\n          return state.definition;\n        }),\n        on: this.on,\n        transitions: this.transitions,\n        entry: this.onEntry,\n        exit: this.onExit,\n        activities: this.activities || [],\n        meta: this.meta,\n        order: this.order || -1,\n        data: this.doneData,\n        invoke: this.invoke,\n        description: this.description,\n        tags: this.tags\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.toJSON = function () {\n    return this.definition;\n  };\n\n  Object.defineProperty(StateNode.prototype, \"on\", {\n    /**\r\n     * The mapping of events to transitions.\r\n     */\n    get: function () {\n      if (this.__cache.on) {\n        return this.__cache.on;\n      }\n\n      var transitions = this.transitions;\n      return this.__cache.on = transitions.reduce(function (map, transition) {\n        map[transition.eventType] = map[transition.eventType] || [];\n        map[transition.eventType].push(transition);\n        return map;\n      }, {});\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"after\", {\n    get: function () {\n      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"transitions\", {\n    /**\r\n     * All the transitions that can be taken from this state node.\r\n     */\n    get: function () {\n      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.getCandidates = function (eventName) {\n    if (this.__cache.candidates[eventName]) {\n      return this.__cache.candidates[eventName];\n    }\n\n    var transient = eventName === NULL_EVENT;\n    var candidates = this.transitions.filter(function (transition) {\n      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions\n\n      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;\n    });\n    this.__cache.candidates[eventName] = candidates;\n    return candidates;\n  };\n  /**\r\n   * All delayed transitions from the config.\r\n   */\n\n\n  StateNode.prototype.getDelayedTransitions = function () {\n    var _this = this;\n\n    var afterConfig = this.config.after;\n\n    if (!afterConfig) {\n      return [];\n    }\n\n    var mutateEntryExit = function (delay, i) {\n      var delayRef = isFunction(delay) ? \"\".concat(_this.id, \":delay[\").concat(i, \"]\") : delay;\n      var eventType = after(delayRef, _this.id);\n\n      _this.onEntry.push(send(eventType, {\n        delay: delay\n      }));\n\n      _this.onExit.push(cancel(eventType));\n\n      return eventType;\n    };\n\n    var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function (transition, i) {\n      var eventType = mutateEntryExit(transition.delay, i);\n      return __assign(__assign({}, transition), {\n        event: eventType\n      });\n    }) : flatten(keys(afterConfig).map(function (delay, i) {\n      var configTransition = afterConfig[delay];\n      var resolvedTransition = isString(configTransition) ? {\n        target: configTransition\n      } : configTransition;\n      var resolvedDelay = !isNaN(+delay) ? +delay : delay;\n      var eventType = mutateEntryExit(resolvedDelay, i);\n      return toArray(resolvedTransition).map(function (transition) {\n        return __assign(__assign({}, transition), {\n          event: eventType,\n          delay: resolvedDelay\n        });\n      });\n    }));\n    return delayedTransitions.map(function (delayedTransition) {\n      var delay = delayedTransition.delay;\n      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {\n        delay: delay\n      });\n    });\n  };\n  /**\r\n   * Returns the state nodes represented by the current state value.\r\n   *\r\n   * @param state The state value or State instance\r\n   */\n\n\n  StateNode.prototype.getStateNodes = function (state) {\n    var _a;\n\n    var _this = this;\n\n    if (!state) {\n      return [];\n    }\n\n    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);\n\n    if (isString(stateValue)) {\n      var initialStateValue = this.getStateNode(stateValue).initial;\n      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this, this.states[stateValue]];\n    }\n\n    var subStateKeys = keys(stateValue);\n    var subStateNodes = subStateKeys.map(function (subStateKey) {\n      return _this.getStateNode(subStateKey);\n    });\n    subStateNodes.push(this);\n    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {\n      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);\n\n      return allSubStateNodes.concat(subStateNode);\n    }, []));\n  };\n  /**\r\n   * Returns `true` if this state node explicitly handles the given event.\r\n   *\r\n   * @param event The event in question\r\n   */\n\n\n  StateNode.prototype.handles = function (event) {\n    var eventType = getEventType(event);\n    return this.events.includes(eventType);\n  };\n  /**\r\n   * Resolves the given `state` to a new `State` instance relative to this machine.\r\n   *\r\n   * This ensures that `.events` and `.nextEvents` represent the correct values.\r\n   *\r\n   * @param state The state to resolve\r\n   */\n\n\n  StateNode.prototype.resolveState = function (state) {\n    var configuration = Array.from(getConfiguration([], this.getStateNodes(state.value)));\n    return new State(__assign(__assign({}, state), {\n      value: this.resolve(state.value),\n      configuration: configuration,\n      done: isInFinalState(configuration, this),\n      tags: getTagsFromConfiguration(configuration)\n    }));\n  };\n\n  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {\n    var stateNode = this.getStateNode(stateValue);\n    var next = stateNode.next(state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {\n    var subStateKeys = keys(stateValue);\n    var stateNode = this.getStateNode(subStateKeys[0]);\n\n    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {\n    var e_2, _a;\n\n    var transitionMap = {};\n\n    try {\n      for (var _b = __values(keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var subStateKey = _c.value;\n        var subStateValue = stateValue[subStateKey];\n\n        if (!subStateValue) {\n          continue;\n        }\n\n        var subStateNode = this.getStateNode(subStateKey);\n\n        var next = subStateNode._transition(subStateValue, state, _event);\n\n        if (next) {\n          transitionMap[subStateKey] = next;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var stateTransitions = keys(transitionMap).map(function (key) {\n      return transitionMap[key];\n    });\n    var enabledTransitions = flatten(stateTransitions.map(function (st) {\n      return st.transitions;\n    }));\n    var willTransition = stateTransitions.some(function (st) {\n      return st.transitions.length > 0;\n    });\n\n    if (!willTransition) {\n      return this.next(state, _event);\n    }\n\n    var entryNodes = flatten(stateTransitions.map(function (t) {\n      return t.entrySet;\n    }));\n    var configuration = flatten(keys(transitionMap).map(function (key) {\n      return transitionMap[key].configuration;\n    }));\n    return {\n      transitions: enabledTransitions,\n      entrySet: entryNodes,\n      exitSet: flatten(stateTransitions.map(function (t) {\n        return t.exitSet;\n      })),\n      configuration: configuration,\n      source: state,\n      actions: flatten(keys(transitionMap).map(function (key) {\n        return transitionMap[key].actions;\n      }))\n    };\n  };\n\n  StateNode.prototype._transition = function (stateValue, state, _event) {\n    // leaf node\n    if (isString(stateValue)) {\n      return this.transitionLeafNode(stateValue, state, _event);\n    } // hierarchical node\n\n\n    if (keys(stateValue).length === 1) {\n      return this.transitionCompoundNode(stateValue, state, _event);\n    } // orthogonal node\n\n\n    return this.transitionParallelNode(stateValue, state, _event);\n  };\n\n  StateNode.prototype.next = function (state, _event) {\n    var e_3, _a;\n\n    var _this = this;\n\n    var eventName = _event.name;\n    var actions = [];\n    var nextStateNodes = [];\n    var selectedTransition;\n\n    try {\n      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var candidate = _c.value;\n        var cond = candidate.cond,\n            stateIn = candidate.in;\n        var resolvedContext = state.context;\n        var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? // Check if in state by ID\n        state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent\n        matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;\n        var guardPassed = false;\n\n        try {\n          guardPassed = !cond || evaluateGuard(this.machine, cond, resolvedContext, _event, state);\n        } catch (err) {\n          throw new Error(\"Unable to evaluate guard '\".concat(cond.name || cond.type, \"' in transition for event '\").concat(eventName, \"' in state node '\").concat(this.id, \"':\\n\").concat(err.message));\n        }\n\n        if (guardPassed && isInState) {\n          if (candidate.target !== undefined) {\n            nextStateNodes = candidate.target;\n          }\n\n          actions.push.apply(actions, __spreadArray([], __read(candidate.actions), false));\n          selectedTransition = candidate;\n          break;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    if (!selectedTransition) {\n      return undefined;\n    }\n\n    if (!nextStateNodes.length) {\n      return {\n        transitions: [selectedTransition],\n        entrySet: [],\n        exitSet: [],\n        configuration: state.value ? [this] : [],\n        source: state,\n        actions: actions\n      };\n    }\n\n    var allNextStateNodes = flatten(nextStateNodes.map(function (stateNode) {\n      return _this.getRelativeStateNodes(stateNode, state.historyValue);\n    }));\n    var isInternal = !!selectedTransition.internal;\n    var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function (n) {\n      return _this.nodesFromChild(n);\n    }));\n    return {\n      transitions: [selectedTransition],\n      entrySet: reentryNodes,\n      exitSet: isInternal ? [] : [this],\n      configuration: allNextStateNodes,\n      source: state,\n      actions: actions\n    };\n  };\n\n  StateNode.prototype.nodesFromChild = function (childStateNode) {\n    if (childStateNode.escapes(this)) {\n      return [];\n    }\n\n    var nodes = [];\n    var marker = childStateNode;\n\n    while (marker && marker !== this) {\n      nodes.push(marker);\n      marker = marker.parent;\n    }\n\n    nodes.push(this); // inclusive\n\n    return nodes;\n  };\n  /**\r\n   * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\r\n   * this state node, it does not escape.\r\n   */\n\n\n  StateNode.prototype.escapes = function (stateNode) {\n    if (this === stateNode) {\n      return false;\n    }\n\n    var parent = this.parent;\n\n    while (parent) {\n      if (parent === stateNode) {\n        return false;\n      }\n\n      parent = parent.parent;\n    }\n\n    return true;\n  };\n\n  StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {\n    var e_4, _a, e_5, _b;\n\n    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);\n    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;\n\n    try {\n      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {\n        var sn = resolvedConfig_1_1.value;\n\n        if (!has(prevConfig, sn)) {\n          transition.entrySet.push(sn);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {\n        var sn = prevConfig_1_1.value;\n\n        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {\n          transition.exitSet.push(sn);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    if (!transition.source) {\n      transition.exitSet = []; // Ensure that root StateNode (machine) is entered\n\n      transition.entrySet.push(this);\n    }\n\n    var doneEvents = flatten(transition.entrySet.map(function (sn) {\n      var events = [];\n\n      if (sn.type !== 'final') {\n        return events;\n      }\n\n      var parent = sn.parent;\n\n      if (!parent.parent) {\n        return events;\n      }\n\n      events.push(done(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.\n      done(parent.id, sn.doneData ? mapContext(sn.doneData, currentContext, _event) : undefined));\n      var grandparent = parent.parent;\n\n      if (grandparent.type === 'parallel') {\n        if (getChildren(grandparent).every(function (parentNode) {\n          return isInFinalState(transition.configuration, parentNode);\n        })) {\n          events.push(done(grandparent.id));\n        }\n      }\n\n      return events;\n    }));\n    transition.exitSet.sort(function (a, b) {\n      return b.order - a.order;\n    });\n    transition.entrySet.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    var entryStates = new Set(transition.entrySet);\n    var exitStates = new Set(transition.exitSet);\n\n    var _c = __read([flatten(Array.from(entryStates).map(function (stateNode) {\n      return __spreadArray(__spreadArray([], __read(stateNode.activities.map(function (activity) {\n        return start(activity);\n      })), false), __read(stateNode.onEntry), false);\n    })).concat(doneEvents.map(raise)), flatten(Array.from(exitStates).map(function (stateNode) {\n      return __spreadArray(__spreadArray([], __read(stateNode.onExit), false), __read(stateNode.activities.map(function (activity) {\n        return stop(activity);\n      })), false);\n    }))], 2),\n        entryActions = _c[0],\n        exitActions = _c[1];\n\n    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);\n    return actions;\n  };\n  /**\r\n   * Determines the next state given the current `state` and sent `event`.\r\n   *\r\n   * @param state The current State instance or state value\r\n   * @param event The event that was sent at the current state\r\n   * @param context The current context (extended state) of the current state\r\n   */\n\n\n  StateNode.prototype.transition = function (state, event, context) {\n    if (state === void 0) {\n      state = this.initialState;\n    }\n\n    var _event = toSCXMLEvent(event);\n\n    var currentState;\n\n    if (state instanceof State) {\n      currentState = context === undefined ? state : this.resolveState(State.from(state, context));\n    } else {\n      var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);\n      var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;\n      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));\n    }\n\n    if (!IS_PRODUCTION && _event.name === WILDCARD) {\n      throw new Error(\"An event cannot have the wildcard type ('\".concat(WILDCARD, \"')\"));\n    }\n\n    if (this.strict) {\n      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {\n        throw new Error(\"Machine '\".concat(this.id, \"' does not accept event '\").concat(_event.name, \"'\"));\n      }\n    }\n\n    var stateTransition = this._transition(currentState.value, currentState, _event) || {\n      transitions: [],\n      configuration: [],\n      entrySet: [],\n      exitSet: [],\n      source: currentState,\n      actions: []\n    };\n    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));\n    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;\n    stateTransition.configuration = __spreadArray([], __read(resolvedConfig), false);\n    return this.resolveTransition(stateTransition, currentState, _event);\n  };\n\n  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {\n    var _a;\n\n    var currentActions = state.actions;\n    state = this.transition(state, _event); // Save original event to state\n    // TODO: this should be the raised event! Delete in V5 (breaking)\n\n    state._event = originalEvent;\n    state.event = originalEvent.data;\n\n    (_a = state.actions).unshift.apply(_a, __spreadArray([], __read(currentActions), false));\n\n    return state;\n  };\n\n  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {\n    var e_6, _a;\n\n    var _this = this;\n\n    if (_event === void 0) {\n      _event = initEvent;\n    }\n\n    if (context === void 0) {\n      context = this.machine.context;\n    }\n\n    var configuration = stateTransition.configuration; // Transition will \"apply\" if:\n    // - this is the initial state (there is no current state)\n    // - OR there are transitions\n\n    var willTransition = !currentState || stateTransition.transitions.length > 0;\n    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;\n    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;\n    var currentContext = currentState ? currentState.context : context;\n    var actions = this.getActions(stateTransition, currentContext, _event, currentState);\n    var activities = currentState ? __assign({}, currentState.activities) : {};\n\n    try {\n      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {\n        var action = actions_1_1.value;\n\n        if (action.type === start$1) {\n          activities[action.activity.id || action.activity.type] = action;\n        } else if (action.type === stop$1) {\n          activities[action.activity.id || action.activity.type] = false;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    var _b = __read(resolveActions(this, currentState, currentContext, _event, actions, this.machine.config.preserveActionOrder), 2),\n        resolvedActions = _b[0],\n        updatedContext = _b[1];\n\n    var _c = __read(partition(resolvedActions, function (action) {\n      return action.type === raise$1 || action.type === send$1 && action.to === SpecialTargets.Internal;\n    }), 2),\n        raisedEvents = _c[0],\n        nonRaisedActions = _c[1];\n\n    var invokeActions = resolvedActions.filter(function (action) {\n      var _a;\n\n      return action.type === start$1 && ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) === invoke;\n    });\n    var children = invokeActions.reduce(function (acc, action) {\n      acc[action.activity.id] = createInvocableActor(action.activity, _this.machine, updatedContext, _event);\n      return acc;\n    }, currentState ? __assign({}, currentState.children) : {});\n    var resolvedConfiguration = resolvedStateValue ? stateTransition.configuration : currentState ? currentState.configuration : [];\n    var isDone = isInFinalState(resolvedConfiguration, this);\n    var nextState = new State({\n      value: resolvedStateValue || currentState.value,\n      context: updatedContext,\n      _event: _event,\n      // Persist _sessionid between states\n      _sessionid: currentState ? currentState._sessionid : null,\n      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,\n      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,\n      actions: resolvedStateValue ? nonRaisedActions : [],\n      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},\n      events: [],\n      configuration: resolvedConfiguration,\n      transitions: stateTransition.transitions,\n      children: children,\n      done: isDone,\n      tags: currentState === null || currentState === void 0 ? void 0 : currentState.tags,\n      machine: this\n    });\n    var didUpdateContext = currentContext !== updatedContext;\n    nextState.changed = _event.name === update || didUpdateContext; // Dispose of penultimate histories to prevent memory leaks\n\n    var history = nextState.history;\n\n    if (history) {\n      delete history.history;\n    } // There are transient transitions if the machine is not in a final state\n    // and if some of the state nodes have transient (\"always\") transitions.\n\n\n    var isTransient = !isDone && (this._transient || configuration.some(function (stateNode) {\n      return stateNode._transient;\n    })); // If there are no enabled transitions, check if there are transient transitions.\n    // If there are transient transitions, continue checking for more transitions\n    // because an transient transition should be triggered even if there are no\n    // enabled transitions.\n    //\n    // If we're already working on an transient transition (by checking\n    // if the event is a NULL_EVENT), then stop to prevent an infinite loop.\n    //\n    // Otherwise, if there are no enabled nor transient transitions, we are done.\n\n    if (!willTransition && (!isTransient || _event.name === NULL_EVENT)) {\n      return nextState;\n    }\n\n    var maybeNextState = nextState;\n\n    if (!isDone) {\n      if (isTransient) {\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, {\n          type: nullEvent\n        }, _event);\n      }\n\n      while (raisedEvents.length) {\n        var raisedEvent = raisedEvents.shift();\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);\n      }\n    } // Detect if state changed\n\n\n    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);\n    maybeNextState.changed = changed; // Preserve original history after raised events\n\n    maybeNextState.history = history;\n    maybeNextState.tags = getTagsFromConfiguration(maybeNextState.configuration);\n    return maybeNextState;\n  };\n  /**\r\n   * Returns the child state node from its relative `stateKey`, or throws.\r\n   */\n\n\n  StateNode.prototype.getStateNode = function (stateKey) {\n    if (isStateId(stateKey)) {\n      return this.machine.getStateNodeById(stateKey);\n    }\n\n    if (!this.states) {\n      throw new Error(\"Unable to retrieve child state '\".concat(stateKey, \"' from '\").concat(this.id, \"'; no child states exist.\"));\n    }\n\n    var result = this.states[stateKey];\n\n    if (!result) {\n      throw new Error(\"Child state '\".concat(stateKey, \"' does not exist on '\").concat(this.id, \"'\"));\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the state node with the given `stateId`, or throws.\r\n   *\r\n   * @param stateId The state ID. The prefix \"#\" is removed.\r\n   */\n\n\n  StateNode.prototype.getStateNodeById = function (stateId) {\n    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;\n\n    if (resolvedStateId === this.id) {\n      return this;\n    }\n\n    var stateNode = this.machine.idMap[resolvedStateId];\n\n    if (!stateNode) {\n      throw new Error(\"Child state node '#\".concat(resolvedStateId, \"' does not exist on machine '\").concat(this.id, \"'\"));\n    }\n\n    return stateNode;\n  };\n  /**\r\n   * Returns the relative state node from the given `statePath`, or throws.\r\n   *\r\n   * @param statePath The string or string array relative path to the state node.\r\n   */\n\n\n  StateNode.prototype.getStateNodeByPath = function (statePath) {\n    if (typeof statePath === 'string' && isStateId(statePath)) {\n      try {\n        return this.getStateNodeById(statePath.slice(1));\n      } catch (e) {// try individual paths\n        // throw e;\n      }\n    }\n\n    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();\n    var currentStateNode = this;\n\n    while (arrayStatePath.length) {\n      var key = arrayStatePath.shift();\n\n      if (!key.length) {\n        break;\n      }\n\n      currentStateNode = currentStateNode.getStateNode(key);\n    }\n\n    return currentStateNode;\n  };\n  /**\r\n   * Resolves a partial state value with its full representation in this machine.\r\n   *\r\n   * @param stateValue The partial state value to resolve.\r\n   */\n\n\n  StateNode.prototype.resolve = function (stateValue) {\n    var _a;\n\n    var _this = this;\n\n    if (!stateValue) {\n      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties\n    }\n\n    switch (this.type) {\n      case 'parallel':\n        return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;\n        });\n\n      case 'compound':\n        if (isString(stateValue)) {\n          var subStateNode = this.getStateNode(stateValue);\n\n          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {\n            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;\n          }\n\n          return stateValue;\n        }\n\n        if (!keys(stateValue).length) {\n          return this.initialStateValue || {};\n        }\n\n        return mapValues(stateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;\n        });\n\n      default:\n        return stateValue || EMPTY_OBJECT;\n    }\n  };\n\n  StateNode.prototype.getResolvedPath = function (stateIdentifier) {\n    if (isStateId(stateIdentifier)) {\n      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];\n\n      if (!stateNode) {\n        throw new Error(\"Unable to find state node '\".concat(stateIdentifier, \"'\"));\n      }\n\n      return stateNode.path;\n    }\n\n    return toStatePath(stateIdentifier, this.delimiter);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateValue\", {\n    get: function () {\n      var _a;\n\n      if (this.__cache.initialStateValue) {\n        return this.__cache.initialStateValue;\n      }\n\n      var initialStateValue;\n\n      if (this.type === 'parallel') {\n        initialStateValue = mapFilterValues(this.states, function (state) {\n          return state.initialStateValue || EMPTY_OBJECT;\n        }, function (stateNode) {\n          return !(stateNode.type === 'history');\n        });\n      } else if (this.initial !== undefined) {\n        if (!this.states[this.initial]) {\n          throw new Error(\"Initial state '\".concat(this.initial, \"' not found on '\").concat(this.key, \"'\"));\n        }\n\n        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);\n      } else {\n        // The finite state value of a machine without child states is just an empty object\n        initialStateValue = {};\n      }\n\n      this.__cache.initialStateValue = initialStateValue;\n      return this.__cache.initialStateValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.getInitialState = function (stateValue, context) {\n    var configuration = this.getStateNodes(stateValue);\n    return this.resolveTransition({\n      configuration: configuration,\n      entrySet: configuration,\n      exitSet: [],\n      transitions: [],\n      source: undefined,\n      actions: []\n    }, undefined, undefined, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialState\", {\n    /**\r\n     * The initial State instance, which includes all actions to be executed from\r\n     * entering the initial state.\r\n     */\n    get: function () {\n      this._init(); // TODO: this should be in the constructor (see note in constructor)\n\n\n      var initialStateValue = this.initialStateValue;\n\n      if (!initialStateValue) {\n        throw new Error(\"Cannot retrieve initial state from simple state '\".concat(this.id, \"'.\"));\n      }\n\n      return this.getInitialState(initialStateValue);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"target\", {\n    /**\r\n     * The target state value of the history state node, if it exists. This represents the\r\n     * default state value to transition to if no history value exists yet.\r\n     */\n    get: function () {\n      var target;\n\n      if (this.type === 'history') {\n        var historyConfig = this.config;\n\n        if (isString(historyConfig.target)) {\n          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;\n        } else {\n          target = historyConfig.target;\n        }\n      }\n\n      return target;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the leaf nodes from a state path relative to this state node.\r\n   *\r\n   * @param relativeStateId The relative state path to retrieve the state nodes\r\n   * @param history The previous state to retrieve history\r\n   * @param resolve Whether state nodes should resolve to initial child state nodes\r\n   */\n\n  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {\n    if (resolve === void 0) {\n      resolve = true;\n    }\n\n    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateNodes\", {\n    get: function () {\n      var _this = this;\n\n      if (isLeafNode(this)) {\n        return [this];\n      } // Case when state node is compound but no initial state is defined\n\n\n      if (this.type === 'compound' && !this.initial) {\n        if (!IS_PRODUCTION) {\n          warn(false, \"Compound state node '\".concat(this.id, \"' has no initial state.\"));\n        }\n\n        return [this];\n      }\n\n      var initialStateNodePaths = toStatePaths(this.initialStateValue);\n      return flatten(initialStateNodePaths.map(function (initialPath) {\n        return _this.getFromRelativePath(initialPath);\n      }));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Retrieves state nodes from a relative path to this state node.\r\n   *\r\n   * @param relativePath The relative path from this state node\r\n   * @param historyValue\r\n   */\n\n  StateNode.prototype.getFromRelativePath = function (relativePath) {\n    if (!relativePath.length) {\n      return [this];\n    }\n\n    var _a = __read(relativePath),\n        stateKey = _a[0],\n        childStatePath = _a.slice(1);\n\n    if (!this.states) {\n      throw new Error(\"Cannot retrieve subPath '\".concat(stateKey, \"' from node with no states\"));\n    }\n\n    var childStateNode = this.getStateNode(stateKey);\n\n    if (childStateNode.type === 'history') {\n      return childStateNode.resolveHistory();\n    }\n\n    if (!this.states[stateKey]) {\n      throw new Error(\"Child state '\".concat(stateKey, \"' does not exist on '\").concat(this.id, \"'\"));\n    }\n\n    return this.states[stateKey].getFromRelativePath(childStatePath);\n  };\n\n  StateNode.prototype.historyValue = function (relativeStateValue) {\n    if (!keys(this.states).length) {\n      return undefined;\n    }\n\n    return {\n      current: relativeStateValue || this.initialStateValue,\n      states: mapFilterValues(this.states, function (stateNode, key) {\n        if (!relativeStateValue) {\n          return stateNode.historyValue();\n        }\n\n        var subStateValue = isString(relativeStateValue) ? undefined : relativeStateValue[key];\n        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);\n      }, function (stateNode) {\n        return !stateNode.history;\n      })\n    };\n  };\n  /**\r\n   * Resolves to the historical value(s) of the parent state node,\r\n   * represented by state nodes.\r\n   *\r\n   * @param historyValue\r\n   */\n\n\n  StateNode.prototype.resolveHistory = function (historyValue) {\n    var _this = this;\n\n    if (this.type !== 'history') {\n      return [this];\n    }\n\n    var parent = this.parent;\n\n    if (!historyValue) {\n      var historyTarget = this.target;\n      return historyTarget ? flatten(toStatePaths(historyTarget).map(function (relativeChildPath) {\n        return parent.getFromRelativePath(relativeChildPath);\n      })) : parent.initialStateNodes;\n    }\n\n    var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;\n\n    if (isString(subHistoryValue)) {\n      return [parent.getStateNode(subHistoryValue)];\n    }\n\n    return flatten(toStatePaths(subHistoryValue).map(function (subStatePath) {\n      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];\n    }));\n  };\n\n  Object.defineProperty(StateNode.prototype, \"stateIds\", {\n    /**\r\n     * All the state node IDs of this state node and its descendant state nodes.\r\n     */\n    get: function () {\n      var _this = this;\n\n      var childStateIds = flatten(keys(this.states).map(function (stateKey) {\n        return _this.states[stateKey].stateIds;\n      }));\n      return [this.id].concat(childStateIds);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"events\", {\n    /**\r\n     * All the event types accepted by this state node and its descendants.\r\n     */\n    get: function () {\n      var e_7, _a, e_8, _b;\n\n      if (this.__cache.events) {\n        return this.__cache.events;\n      }\n\n      var states = this.states;\n      var events = new Set(this.ownEvents);\n\n      if (states) {\n        try {\n          for (var _c = __values(keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var stateId = _d.value;\n            var state = states[stateId];\n\n            if (state.states) {\n              try {\n                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var event_1 = _f.value;\n                  events.add(\"\".concat(event_1));\n                }\n              } catch (e_8_1) {\n                e_8 = {\n                  error: e_8_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_8) throw e_8.error;\n                }\n              }\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n\n      return this.__cache.events = Array.from(events);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"ownEvents\", {\n    /**\r\n     * All the events that have transitions directly from this state node.\r\n     *\r\n     * Excludes any inert events.\r\n     */\n    get: function () {\n      var events = new Set(this.transitions.filter(function (transition) {\n        return !(!transition.target && !transition.actions.length && transition.internal);\n      }).map(function (transition) {\n        return transition.eventType;\n      }));\n      return Array.from(events);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateNode.prototype.resolveTarget = function (_target) {\n    var _this = this;\n\n    if (_target === undefined) {\n      // an undefined target signals that the state node should not transition from that state when receiving that event\n      return undefined;\n    }\n\n    return _target.map(function (target) {\n      if (!isString(target)) {\n        return target;\n      }\n\n      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,\n      // do not include machine key on target\n\n      if (isInternalTarget && !_this.parent) {\n        return _this.getStateNodeByPath(target.slice(1));\n      }\n\n      var resolvedTarget = isInternalTarget ? _this.key + target : target;\n\n      if (_this.parent) {\n        try {\n          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);\n\n          return targetStateNode;\n        } catch (err) {\n          throw new Error(\"Invalid transition definition for state node '\".concat(_this.id, \"':\\n\").concat(err.message));\n        }\n      } else {\n        return _this.getStateNodeByPath(resolvedTarget);\n      }\n    });\n  };\n\n  StateNode.prototype.formatTransition = function (transitionConfig) {\n    var _this = this;\n\n    var normalizedTarget = normalizeTarget(transitionConfig.target);\n    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {\n      return isString(_target) && _target[0] === _this.delimiter;\n    }) : true;\n    var guards = this.machine.options.guards;\n    var target = this.resolveTarget(normalizedTarget);\n\n    var transition = __assign(__assign({}, transitionConfig), {\n      actions: toActionObjects(toArray(transitionConfig.actions)),\n      cond: toGuard(transitionConfig.cond, guards),\n      target: target,\n      source: this,\n      internal: internal,\n      eventType: transitionConfig.event,\n      toJSON: function () {\n        return __assign(__assign({}, transition), {\n          target: transition.target ? transition.target.map(function (t) {\n            return \"#\".concat(t.id);\n          }) : undefined,\n          source: \"#\".concat(_this.id)\n        });\n      }\n    });\n\n    return transition;\n  };\n\n  StateNode.prototype.formatTransitions = function () {\n    var e_9, _a;\n\n    var _this = this;\n\n    var onConfig;\n\n    if (!this.config.on) {\n      onConfig = [];\n    } else if (Array.isArray(this.config.on)) {\n      onConfig = this.config.on;\n    } else {\n      var _b = this.config.on,\n          _c = WILDCARD,\n          _d = _b[_c],\n          wildcardConfigs = _d === void 0 ? [] : _d,\n          strictTransitionConfigs_1 = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\"]);\n\n      onConfig = flatten(keys(strictTransitionConfigs_1).map(function (key) {\n        if (!IS_PRODUCTION && key === NULL_EVENT) {\n          warn(false, \"Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. \" + \"Please check the `on` configuration for \\\"#\".concat(_this.id, \"\\\".\"));\n        }\n\n        var transitionConfigArray = toTransitionConfigArray(key, strictTransitionConfigs_1[key]);\n\n        if (!IS_PRODUCTION) {\n          validateArrayifiedTransitions(_this, key, transitionConfigArray);\n        }\n\n        return transitionConfigArray;\n      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));\n    }\n\n    var eventlessConfig = this.config.always ? toTransitionConfigArray('', this.config.always) : [];\n    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];\n\n    if (!IS_PRODUCTION) {\n      warn(!(this.config.onDone && !this.parent), \"Root nodes cannot have an \\\".onDone\\\" transition. Please check the config of \\\"\".concat(this.id, \"\\\".\"));\n    }\n\n    var invokeConfig = flatten(this.invoke.map(function (invokeDef) {\n      var settleTransitions = [];\n\n      if (invokeDef.onDone) {\n        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)), false));\n      }\n\n      if (invokeDef.onError) {\n        settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)), false));\n      }\n\n      return settleTransitions;\n    }));\n    var delayedTransitions = this.after;\n    var formattedTransitions = flatten(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(doneConfig), false), __read(invokeConfig), false), __read(onConfig), false), __read(eventlessConfig), false).map(function (transitionConfig) {\n      return toArray(transitionConfig).map(function (transition) {\n        return _this.formatTransition(transition);\n      });\n    }));\n\n    try {\n      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {\n        var delayedTransition = delayedTransitions_1_1.value;\n        formattedTransitions.push(delayedTransition);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    return formattedTransitions;\n  };\n\n  return StateNode;\n}();\n\nexport { StateNode };\n"]},"metadata":{},"sourceType":"module"}